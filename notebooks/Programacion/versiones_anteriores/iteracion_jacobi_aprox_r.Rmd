---
title: "iteraciones_jacobi_aprox"
author: "equipo5"
date: "18/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Iteraciones como van quedando las actualizaciones del algoritmo de aproximación de jacc

```{r}
# Limpia área de trabajo
rm(list = ls())
```

```{r}

ortogonal <- function(u,v,TOL=10^-8){
  # Verifica si dos vectores son ortogonales, de acuerdo a cierto nivel de tolerancia, 
  # arrojando un 1 si lo es, y un 0 si no lo es.
  # Args: 
  #   u (vector): vector de dimension n,
  #   v (vector): vector de dimension n, 
  #   TOL (numeric): real positivo, que sirve como parametro de tolerancia para evaluar ortogonalidad de u y v. 
  #   Notas: 
  #   1) Valor por default TOL es 10^-8
  #   2) Se sugiere una TOL mayor a 10^-32.
  # Returns: 
  #   Valor booleano 0 (no son ortongoales), 1 (son ortogonales)
  if ( norm(u,type ="2") < TOL | norm(v,type ="2") < TOL){ret<-0} 
  else{ 
    if( abs(u%*%v)/(norm(u,type ="2")*norm(v,type ="2")) < TOL){ret<-1}
    else{ret<-0}  
  }
  ret
}


```


```{r}

signo<-function(x) {
  # Indica el signo de un número x
  # Args: 
  #    x (numeric): número a revisar
  # Returns:
  #    1 si el número es positivo o cero
  #    -1 si el número es negativo
  
  ifelse(x<0,-1,1)
}

```

```{r}

A <- matrix(c(-1.76884571,  0.07555227, -1.1306297 , -0.65143017, -0.89311563,-1.27410098,
                     -0.06115443,  0.06451384,  0.41011295, -0.57288249, -0.80133362,1.31203519,
                     1.27469887, -1.2143576 ,  0.31371941, -1.44482142, -0.3689613 ,-0.76922658,
                     0.3926161 ,  0.05729383,  2.08997884,  0.04197131, -0.04834072,-0.51315392,
                     -0.08458928, -1.21545008, -1.41293073, -1.48691055,  0.38222486,0.937673,
                     1.77267804,  0.87882801,  0.33171912, -0.30603567,  1.24026615,-0.21562684,
                     0.15592948,  0.09805553,  0.83209585,  2.04520542, -0.31681392,-1.31283291,
                     -1.75445746,  0.10209408, -1.36150208,  0.48178488, -0.20832874,-0.09186351,
                     0.70268816,  0.10365506,  0.62123638,  0.95411497,  2.03781352, -0.48445122),
                   nrow = 9,ncol = 6, byrow = TRUE)

```

```{r}
#dimensiones
(n<-dim(A)[2]) #numero de columnas
(m<-dim(A)[1]) #numero de filas
(nmax<-n*(n-1)/2)
```

```{r}
#inicializa valores del ciclo
ak<-A
vk<-diag(n)
sig <- NULL
uk <- ak
num_col_ortogonal<-0
k<-0
stop <- FALSE

TOL = 10^-8
```

### Primera iteracion

```{r}
i <- 1
j <- 2
```

```{r}
# columnas  a utilizar
col_j<-ak[,j]
col_i<-ak[,i]

col_i
col_j
```

```{r}
# checar ortogonalidad
ortogonal(col_i,col_j,TOL)
```

```{r}
#calcula coeficientes 
a<-col_i%*%col_i
b<-col_j%*%col_j
c<-col_i%*%col_j
        
a
b
c
```

```{r}
#calcula la rotacion givens que diagonaliza
epsilon<-(b-a)/(2*c)
t<-signo(epsilon)/(abs(epsilon)+sqrt(1+epsilon**2))
cs<-1/sqrt(1+t**2)
sn<-cs*t
        
epsilon; t; cs; sn   
```

```{r}
#actualiza las columnas de la matriz ak
temp<-ak[,i] 
ak[,i]<-c(cs)*temp-c(sn)*ak[,j]
ak[,j]<-c(sn)*temp+c(cs)*ak[,j]

temp
ak[,i]
ak[,j]
```

```{r}
#actualiza las columnas de la matriz vk
temp<-vk[,i] #cambio
vk[,i]<-c(cs)*temp-c(sn)*vk[,j]
vk[,j]<-c(sn)*temp+c(cs)*vk[,j]             
      
temp
vk[,i]
vk[,j]
```

```{r}
#Obtener sigma
sig<-apply(ak, 2, function(x){norm(x,"2")})
sig
```

### segunda iteración

```{r}
i <- 2
j <- 3
```

```{r}
# columnas  a utilizar
col_j<-ak[,j]
col_i<-ak[,i]

col_i
col_j
```

```{r}
# checar ortogonalidad
ortogonal(col_i,col_j,TOL)
```

```{r}
#calcula coeficientes 
a<-col_i%*%col_i
b<-col_j%*%col_j
c<-col_i%*%col_j
        
a
b
c
```

```{r}
#calcula la rotacion givens que diagonaliza
epsilon<-(b-a)/(2*c)
t<-signo(epsilon)/(abs(epsilon)+sqrt(1+epsilon**2))
cs<-1/sqrt(1+t**2)
sn<-cs*t
        
epsilon; t; cs; sn   
```

```{r}
#actualiza las columnas de la matriz ak
temp<-ak[,i] 
ak[,i]<-c(cs)*temp-c(sn)*ak[,j]
ak[,j]<-c(sn)*temp+c(cs)*ak[,j]

temp
ak[,i]
ak[,j]
```

```{r}
#actualiza las columnas de la matriz vk
temp<-vk[,i] #cambio
vk[,i]<-c(cs)*temp-c(sn)*vk[,j]
vk[,j]<-c(sn)*temp+c(cs)*vk[,j]             
      
temp
vk[,i]
vk[,j]
```

```{r}
#Obtener sigma
sig<-apply(ak, 2, function(x){norm(x,"2")})
sig
```



### tercera iteración

```{r}
i <- 3
j <- 4
```

```{r}
# columnas  a utilizar
col_j<-ak[,j]
col_i<-ak[,i]

col_i
col_j
```

```{r}
# checar ortogonalidad
ortogonal(col_i,col_j,TOL)
```

```{r}
#calcula coeficientes 
a<-col_i%*%col_i
b<-col_j%*%col_j
c<-col_i%*%col_j
        
a
b
c
```

```{r}
#calcula la rotacion givens que diagonaliza
epsilon<-(b-a)/(2*c)
t<-signo(epsilon)/(abs(epsilon)+sqrt(1+epsilon**2))
cs<-1/sqrt(1+t**2)
sn<-cs*t
        
epsilon; t; cs; sn   
```

```{r}
#actualiza las columnas de la matriz ak
temp<-ak[,i] 
ak[,i]<-c(cs)*temp-c(sn)*ak[,j]
ak[,j]<-c(sn)*temp+c(cs)*ak[,j]

temp
ak[,i]
ak[,j]
```

```{r}
#actualiza las columnas de la matriz vk
temp<-vk[,i] #cambio
vk[,i]<-c(cs)*temp-c(sn)*vk[,j]
vk[,j]<-c(sn)*temp+c(cs)*vk[,j]             
      
temp
vk[,i]
vk[,j]
```

```{r}
#Obtener sigma
sig<-apply(ak, 2, function(x){norm(x,"2")})
sig
```



