---
title: "Ejemplo_SVD_from_Jacobi_R"
output: html_document
---

Definifir funciones que se utilizarán
```{r}

ortogonal <- function(u,v,TOL=10^-8){
  # Verifica si dos vectores son ortogonales, de acuerdo a cierto nivel de tolerancia, 
  # arrojando un 1 si lo es, y un 0 si no lo es.
  # Args: 
  #   u (vector): vector de dimension n,
  #   v (vector): vector de dimension n, 
  #   TOL (numeric): real positivo, que sirve como parametro de tolerancia para evaluar ortogonalidad de u y v. 
  #   Notas: 
  #   1) Valor por default TOL es 10^-8
  #   2) Se sugiere una TOL mayor a 10^-32.
  # Returns: 
  #   Valor booleano 0 (no son ortongoales), 1 (son ortogonales)
  if ( norm(u,type ="2") < TOL | norm(v,type ="2") < TOL){ret<-0} 
  else{ 
    if((u%*%v)/(norm(u,type ="2")*norm(v,type ="2")) < TOL){ret<-1}
    else{ret<-0}  
  }
  ret
}


signo<-function(x) {
  # Indica el signo de un número x
  # Args: 
  #    x (numeric): número a revisar
  # Returns:
  #    1 si el número es positivo o cero
  #    -1 si el número es negativo
  
  ifelse(x<0,-1,1)
}


svd_jacobi_aprox <- function(A,TOL,maxsweep){
  # Calcula la descomposición de una matriz A en sus componentes U, S V, 
  # utilizando el método de Jacobi para calcular la factorización SVD.De esta forma 
  # la matriz A queda descompuesta de la siguiente forma: A = U*S*t(V).
  # Args: 
  #    A (matriz): Matriz de entrada (nxm) de números reales a la que se le calculará la descomposición SVD.
  #    TOL (numeric): controla la convergencia del método, siendo un valor real de 10^-8 (sugerido en la nota 3.3.d.SVD)
  #    Nota: Se sugiere una TOL mayor a 10^-32.
  #    maxsweep (numeric): número máximo de sweeps,donde cada sweep consiste de un número máximo(nmax)
  #    de rotaciones; y en cada sweep se ortogonalizan 2 columnas.
  # Returns: 
  #   Lista con 3 elementos, donde el primer elemento representa a la matriz S(mxm) matriz diagonal,el segundo a la matriz U(nxm)
  #   y el tercero y último a la matriz V (mxm).En conjunto estas tres matrices componen la factorización SVD de la matriz de entrada A.
  # Nota: Esta función estima la SVD thin,la cual calcula unicamente las m columnas de U correspondientes a los m renglones de V. De esta
  # manera las columnas restantes de U no son calculadas, provocando una mejora significativa en velocidad de ejecución comparada con la 
  # la Full SVD. Referencia: https://en.wikipedia.org/wiki/Singular_value_decomposition#Thin_SVD.
  
  #dimensiones
  n<-dim(A)[2] #numero de columnas
  m<-dim(A)[1] #numero de filas
  nmax<-n*(n-1)/2
  
  #inicializa valores del ciclo
  ak<-A
  vk<-diag(n)
  sig <- NULL
  uk <- ak
  num_col_ortogonal<-0
  k<-0
  stop<-FALSE
  
  while(k<=maxsweep & num_col_ortogonal<nmax){
    num_col_ortogonal<-0
    for(i in 1:(n-1)){
      for(j in (i+1):n){
        col_j<-ak[,j]
        col_i<-ak[,i]
        
        #comprueba ortogonalidad  
        if(ortogonal(col_i,col_j,TOL)==1){
          num_col_ortogonal<-num_col_ortogonal+1
        }
        else{
          #calcula coeficientes de la matriz
          a<-col_i%*%col_i
          b<-col_j%*%col_j
          c<-col_i%*%col_j
          
          #si c es cercano a cero no actualiza
          if(c<TOL){
            stop<-TRUE
            break}
          
          #calcula la rotacion givens que diagonaliza
          epsilon<-(b-a)/(2*c)
          t<-signo(epsilon)/(abs(epsilon)+sqrt(1+epsilon**2))
          cs<-1/sqrt(1+t**2)
          sn<-cs*t
          
          #actualiza las columnas de la matriz ak
          temp<-ak[,i] 
          ak[,i]<-c(cs)*temp-c(sn)*ak[,j]
          ak[,j]<-c(sn)*temp+c(cs)*ak[,j]
          
          
          #actualiza las columnas de la matriz vk
          temp<-vk[,i] #cambio
          vk[,i]<-c(cs)*temp-c(sn)*vk[,j]
          vk[,j]<-c(sn)*temp+c(cs)*vk[,j]             
        }#cierra else
      }#cierra for j
      if(stop==TRUE){
        stop<-FALSE
        break
      }
    }#cierra for i
    k<-k+1
  }#cierra while
  
  #Obtener sigma
  sig<-apply(ak, 2, function(x){norm(x,"2")})
  
  #Obtener U
  for(i in 1:n){
    if (sig[i]<TOL){
      uk[,i]<-0  
    } else{
      uk[,i] <- ak[,i]/sig[i]
    }
  }
  
  # Indices de sigma ordenada en forma decreciente para ordenar V,S,U
  index <- order(sig,decreasing = TRUE)
  vk <- vk[,index]
  S <- diag(sig[index])
  uk <- uk[,index]
  
  list(S = S, U = uk, V= vk)
}


```


Definir una matriz de prueba

```{r}

matriz_A <- matrix(c(-1.76884571,  0.07555227, -1.1306297 , -0.65143017, -0.89311563,-1.27410098,
              -0.06115443,  0.06451384,  0.41011295, -0.57288249, -0.80133362,1.31203519,
               1.27469887, -1.2143576 ,  0.31371941, -1.44482142, -0.3689613 ,-0.76922658,
               0.3926161 ,  0.05729383,  2.08997884,  0.04197131, -0.04834072,-0.51315392,
              -0.08458928, -1.21545008, -1.41293073, -1.48691055,  0.38222486,0.937673,
               1.77267804,  0.87882801,  0.33171912, -0.30603567,  1.24026615,-0.21562684,
               0.15592948,  0.09805553,  0.83209585,  2.04520542, -0.31681392,-1.31283291,
              -1.75445746,  0.10209408, -1.36150208,  0.48178488, -0.20832874,-0.09186351,
              0.70268816,  0.10365506,  0.62123638,  0.95411497,  2.03781352, -0.48445122),
              nrow = 9,ncol = 6, byrow = TRUE)

matriz_A

```

Ejecutar función

```{r}

svd_jacobi_aprox(matriz_A,10**-8,50)

```

